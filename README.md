# messari-metrics

## Key takeaways

1. Used Goa (https://github.com/goadesign/goa) to generate design-based service, see: `design/design.go`
    - Took some extra time on this as I've been wanting to learn Goa
    - See `gen/http/openapi*` for autogenerated specs
2. Basic Messari API client with two endpoints, see: `messari/client.go`
    - `https://data.messari.io/api/v2/assets` used for aggregate caching
    - `https://data.messari.io/api/v1/assets/{slug}/metrics`  used for individual metric lookup
3. Implemented Metrics Service API, see: `endpoints.go`
    - `/aggregate` for aggregate asset metrics
    - `/asset/{slug}` for individual asset metrics
4. Implemented an AssetCache for reduced aggregate request times, see: `asset_cache.go`
    - I would move this to a Redis-backed cache in a real world scenario
5. Wrote some tests, but would write a lot more in the real world

## Setup

1. Check out project: `git clone git@github.com:jordanfowler/messari-metrics.git`
2. From project root: `go mod download`
3. Export your Messari API Key: `export MESSARI_API_KEY=...` 
4. From project root: `go run .`

## API Requests

1. Single asset metrics endpoint: `localhost:8000/asset/{slug}`
    - Example: `curl localhost:8000/asset/btc`
2. Aggregate asset metrics (query params optional): `curl localhost:8000/aggregate[?tags=...|sector=...]`
    - Mkt Cap >= 100M: `curl localhost:8000/aggregate`
    - Tag example: `curl localhost:8000/aggregate?tag=NFT`
    - Sector example: `curl localhost:8000/aggregate?sector=Scaling`

## Caveats

- Aggregate endpoint will take a few seconds to have a fully warmed cache
- Until removing Messari API rate limiting, aggregate endpoint may encounter errors with sub-requests
